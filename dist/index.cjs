"use strict";const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),n=(r=void 0,n=null)=>{const s=t=>e(n?.persist)&&n.persist(t);let i=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const n=r(e,(e=>{t(e),n()}));return n},unsubscribeAll:t=>e.delete(t)}})(),o=r;s(o);const c=()=>o,u=e=>{o!==e&&(o=e,s(o),i.publish("change",o))};return{set:u,get:c,update:e=>{t(e,"[update]"),u(e(c()))},subscribe:e=>(t(e,"[subscribe]"),e(o),i.subscribe("change",e))}};exports.createTtlQueueStore=(s=0,i={})=>{const o=(...e)=>i?.logger?.apply(null,[Date.now(),...e]);let c=[];const u=n();let l=null;const b=()=>{l&&(clearTimeout(l),l=null)};let a=0;const p=()=>{c[0]&&!c[0]._isHead&&(o("_syncHead",c[0]),c[0]._isHead=!0,l&&(o("Unexpected timer"),b()),l=setTimeout((()=>{l=null,g()}),c[0].ttl)),u.set(c[0])},g=()=>{o("_dequeue"),c=[...c.slice(1)],p()},{subscribe:h,get:f}=((s,i,o=null)=>{const c=t=>e(o?.persist)&&o.persist(t),u=n(o?.initialValue),l=[];if(s.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>l.push(e)))()})),!e(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,a=[];return{get:u.get,subscribe:e=>{t(e,"[derived.subscribe]"),b++||s.forEach(((e,t)=>{a.push(e.subscribe((e=>{l[t]=e,1===i.length?(u.set(i(l)),c(u.get())):i(l,(e=>{u.set(e),c(u.get())}))})))}));const r=u.subscribe(e);return()=>{--b||(a.forEach((e=>e())),a=[]),r()}}}})([u],(([e])=>e?.item));return{subscribe:h,get:f,enqueue:(e,t)=>{t??=s;const r=++a;let n="Expecting positive non-zero number of milliseconds";if("number"!=typeof t)throw new TypeError(`${n} (1)`);if(t<=0)throw new TypeError(`${n} (2)`);return o("enqueue",{item:e,ttl:t,id:r}),c=[...c,{item:e,ttl:t,id:r}],p(),r},reset:()=>{o("reset"),b(),c=[],p()}}};

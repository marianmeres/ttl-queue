!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["ttl-queue"]={})}(this,(function(e){"use strict";const t=e=>"function"==typeof e,r=(e,r="")=>{if(!t(e))throw new TypeError(`${r} Expecting function arg`.trim())},n=e=>t(e.subscribe),s=(e=void 0,n=null)=>{const s=e=>t(n?.persist)&&n.persist(e);let i=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const n=r(e,(e=>{t(e),n()}));return n},unsubscribeAll:t=>e.delete(t)}})(),o=e;s(o);const u=()=>o,c=e=>{o!==e&&(o=e,s(o),i.publish("change",o))};return{set:c,get:u,update:e=>{r(e,"[update]"),c(e(u()))},subscribe:e=>(r(e,"[subscribe]"),e(o),i.subscribe("change",e))}};e.createTtlQueueStore=(e=0,i={})=>{const o=(...e)=>i?.logger?.apply(null,[Date.now(),...e]);let u=[];const c=s();let l=null;const b=()=>{l&&(clearTimeout(l),l=null)};let p=0;const a=()=>{u[0]&&!u[0]._isHead&&(o("_syncHead",u[0]),u[0]._isHead=!0,l&&(o("Unexpected timer"),b()),l=setTimeout((()=>{l=null,f()}),u[0].ttl)),c.set(u[0])},f=()=>{o("_dequeue"),u=[...u.slice(1)],a()},{subscribe:d,get:g}=((e,i,o=null)=>{const u=e=>t(o?.persist)&&o.persist(e),c=s(o?.initialValue),l=[];if(e.forEach((e=>{if(!n(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>l.push(e)))()})),!t(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let b=0,p=[];return{get:c.get,subscribe:t=>{r(t,"[derived.subscribe]"),b++||e.forEach(((e,t)=>{p.push(e.subscribe((e=>{l[t]=e,1===i.length?(c.set(i(l)),u(c.get())):i(l,(e=>{c.set(e),u(c.get())}))})))}));const n=c.subscribe(t);return()=>{--b||(p.forEach((e=>e())),p=[]),n()}}}})([c],(([e])=>e?.item));return{subscribe:d,get:g,enqueue:(t,r)=>{r??=e;const n=++p;let s="Expecting positive non-zero number of milliseconds";if("number"!=typeof r)throw new TypeError(`${s} (1)`);if(r<=0)throw new TypeError(`${s} (2)`);return o("enqueue",{item:t,ttl:r,id:n}),u=[...u,{item:t,ttl:r,id:n}],a(),n},reset:()=>{o("reset"),b(),u=[],a()}}}}));
